<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VIP Journey - Cart√µes X Premium</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e1b4b 0%, #312e81 50%, #1e1b4b 100%);
            min-height: 100vh;
            color: white;
            overflow: hidden;
        }

        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 320px;
            z-index: 100;
            background: rgba(30, 27, 75, 0.95);
            backdrop-filter: blur(10px);
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .header-left { display: flex; align-items: center; gap: 15px; }

        .back-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: white;
            padding: 10px 18px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
            font-size: 14px;
        }

        .back-btn:hover { background: rgba(255,255,255,0.2); }

        .title { font-size: 18px; font-weight: 700; }

        .header-stats { display: flex; align-items: center; gap: 12px; }

        .stat-pill {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
        }

        .heart { font-size: 16px; }
        .heart.lost { opacity: 0.25; filter: grayscale(1); }

        /* Map Container */
        .map-container {
            position: fixed;
            top: 60px;
            left: 0;
            right: 320px;
            bottom: 80px;
            overflow: hidden;
        }

        .map {
            width: 100%;
            height: 100%;
            background-size: cover;
            background-position: center;
            position: relative;
        }

        .map::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(30,27,75,0.5), rgba(30,27,75,0.7));
        }

        .routes {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
        }

        .route {
            stroke-width: 5;
            stroke-linecap: round;
            opacity: 0.5;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
        }

        .route.completed { stroke: #22c55e !important; opacity: 1; stroke-width: 6; }
        .route.active { stroke: #f59e0b !important; opacity: 1; stroke-dasharray: 12 6; animation: routeDash 1s linear infinite; }

        @keyframes routeDash { to { stroke-dashoffset: -18; } }

        .nodes { position: absolute; inset: 0; }

        .node {
            position: absolute;
            transform: translate(-50%, -50%);
            cursor: pointer;
            z-index: 10;
            transition: transform 0.3s;
        }

        .node:hover { transform: translate(-50%, -50%) scale(1.1); }

        .node-inner {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            background: linear-gradient(135deg, #4b5563, #374151);
            border: 3px solid rgba(255,255,255,0.2);
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            transition: all 0.3s;
        }

        .node.locked .node-inner { opacity: 0.4; filter: grayscale(1); cursor: not-allowed; }
        .node.locked:hover { transform: translate(-50%, -50%); }

        .node.unlocked .node-inner {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border-color: #60a5fa;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.4);
        }

        .node.current .node-inner {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border-color: #fbbf24;
            box-shadow: 0 0 25px rgba(245, 158, 11, 0.6);
            animation: currentPulse 2s ease-in-out infinite;
        }

        .node.completed .node-inner {
            background: linear-gradient(135deg, #22c55e, #16a34a);
            border-color: #4ade80;
        }

        .node.boss .node-inner { width: 75px; height: 75px; font-size: 30px; }

        /* === EFECTOS POR TIPO DE NODO === */
        
        /* Boss - Efecto de fuego/pulsaci√≥n amenazante */
        .node.boss .node-inner {
            animation: bossPulse 1.5s ease-in-out infinite;
            box-shadow: 0 0 30px rgba(239, 68, 68, 0.6), 0 0 60px rgba(239, 68, 68, 0.3);
        }
        .node.boss::before {
            content: '';
            position: absolute;
            inset: -15px;
            background: radial-gradient(circle, rgba(239,68,68,0.3) 0%, transparent 70%);
            animation: bossAura 2s ease-in-out infinite;
            pointer-events: none;
            z-index: -1;
        }
        @keyframes bossPulse {
            0%, 100% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(1.08); filter: brightness(1.2); }
        }
        @keyframes bossAura {
            0%, 100% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        /* Start - Efecto de portal brillante */
        .node[data-type="start"] .node-inner {
            animation: startGlow 2s ease-in-out infinite;
            box-shadow: 0 0 25px rgba(34, 197, 94, 0.5);
        }
        .node[data-type="start"]::after {
            content: '‚ú®';
            position: absolute;
            top: -10px;
            right: -10px;
            font-size: 16px;
            animation: sparkleFloat 1.5s ease-in-out infinite;
        }
        @keyframes startGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(34, 197, 94, 0.4); }
            50% { box-shadow: 0 0 40px rgba(34, 197, 94, 0.8); }
        }
        @keyframes sparkleFloat {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-5px) rotate(15deg); }
        }

        /* Checkpoint - Efecto de sanaci√≥n */
        .node[data-type="checkpoint"] .node-inner {
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.4);
        }
        .node[data-type="checkpoint"]::before {
            content: '';
            position: absolute;
            inset: -8px;
            border: 2px solid rgba(34, 197, 94, 0.5);
            border-radius: 50%;
            animation: healPulse 2s ease-out infinite;
        }
        @keyframes healPulse {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        /* Treasure - Efecto de brillo dorado */
        .node[data-type="treasure"] .node-inner {
            animation: treasureShine 3s ease-in-out infinite;
            box-shadow: 0 0 25px rgba(245, 158, 11, 0.6);
        }
        .node[data-type="treasure"]::before,
        .node[data-type="treasure"]::after {
            content: '‚ú¶';
            position: absolute;
            color: #f59e0b;
            font-size: 12px;
            animation: treasureSparkle 1s ease-in-out infinite;
        }
        .node[data-type="treasure"]::before { top: -5px; left: 10px; animation-delay: 0s; }
        .node[data-type="treasure"]::after { bottom: 10px; right: -5px; animation-delay: 0.5s; }
        @keyframes treasureShine {
            0%, 100% { filter: brightness(1) saturate(1); }
            50% { filter: brightness(1.3) saturate(1.2); }
        }
        @keyframes treasureSparkle {
            0%, 100% { opacity: 0; transform: scale(0.5); }
            50% { opacity: 1; transform: scale(1); }
        }

        /* Mystery - Efecto de niebla misteriosa */
        .node[data-type="mystery"] .node-inner {
            animation: mysteryFloat 3s ease-in-out infinite;
        }
        .node[data-type="mystery"]::before {
            content: '';
            position: absolute;
            inset: -20px;
            background: radial-gradient(circle, rgba(168, 85, 247, 0.4) 0%, transparent 70%);
            animation: mysteryFog 4s ease-in-out infinite;
            filter: blur(5px);
            pointer-events: none;
            z-index: -1;
        }
        @keyframes mysteryFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }
        @keyframes mysteryFog {
            0%, 100% { opacity: 0.4; transform: scale(1) rotate(0deg); }
            50% { opacity: 0.8; transform: scale(1.2) rotate(180deg); }
        }

        /* Final - Efecto arco√≠ris √©pico */
        .node[data-type="final"] .node-inner {
            animation: finalRainbow 4s linear infinite, finalPulse 2s ease-in-out infinite;
            box-shadow: 0 0 40px rgba(168, 85, 247, 0.6);
        }
        .node[data-type="final"]::before {
            content: '';
            position: absolute;
            inset: -5px;
            border-radius: 50%;
            background: conic-gradient(
                #ef4444, #f59e0b, #22c55e, #3b82f6, #a855f7, #ef4444
            );
            animation: finalRainbow 3s linear infinite;
            z-index: -1;
            filter: blur(4px);
        }
        @keyframes finalRainbow {
            to { filter: hue-rotate(360deg); }
        }
        @keyframes finalPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* Efecto de rasgadura para boss (aparece al hacer click) */
        .boss-slash-effect {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 9999;
            overflow: hidden;
        }
        .boss-slash {
            position: absolute;
            width: 200%;
            height: 8px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255,0,0,0.1) 20%, 
                rgba(255,50,50,0.8) 50%, 
                rgba(255,0,0,0.1) 80%, 
                transparent 100%);
            filter: blur(2px);
            animation: slashMove 0.4s ease-out forwards;
        }
        .boss-slash:nth-child(1) { top: 30%; left: -50%; transform: rotate(-15deg); animation-delay: 0s; }
        .boss-slash:nth-child(2) { top: 50%; left: -50%; transform: rotate(10deg); animation-delay: 0.1s; }
        .boss-slash:nth-child(3) { top: 70%; left: -50%; transform: rotate(-5deg); animation-delay: 0.2s; }
        
        @keyframes slashMove {
            0% { transform: translateX(-100%) rotate(-15deg); opacity: 0; }
            20% { opacity: 1; }
            100% { transform: translateX(100%) rotate(-15deg); opacity: 0; }
        }

        /* Efecto de part√≠culas para zonas */
        .zone-particles {
            position: absolute;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
        }
        .particle {
            position: absolute;
            opacity: 0.6;
            animation: particleFloat 8s linear infinite;
        }
        @keyframes particleFloat {
            0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
            10% { opacity: 0.6; }
            90% { opacity: 0.6; }
            100% { transform: translateY(-100px) rotate(360deg); opacity: 0; }
        }

        @keyframes currentPulse {
            0%, 100% { box-shadow: 0 0 25px rgba(245, 158, 11, 0.5); transform: scale(1); }
            50% { box-shadow: 0 0 35px rgba(245, 158, 11, 0.8); transform: scale(1.05); }
        }

        .node-label {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 6px;
            white-space: nowrap;
            font-size: 10px;
            font-weight: 600;
            background: rgba(0,0,0,0.85);
            padding: 4px 10px;
            border-radius: 6px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .node:hover .node-label { opacity: 1; }

        .node-check {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 20px;
            height: 20px;
            background: #22c55e;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            border: 2px solid white;
        }

        .node-stars {
            position: absolute;
            bottom: -14px;
            left: 50%;
            transform: translateX(-50%);
            color: #f59e0b;
            font-size: 10px;
            letter-spacing: 1px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.5);
        }

        /* Bottom Panel */
        .bottom-panel {
            position: fixed;
            bottom: 15px;
            left: 20px;
            right: 340px;
            background: rgba(30, 27, 75, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 16px;
            padding: 12px 25px;
            display: flex;
            justify-content: space-around;
            z-index: 100;
        }

        .bottom-stat {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            font-size: 14px;
        }

        .bottom-stat i { font-size: 16px; }
        .bottom-stat i.fa-star { color: #f59e0b; }
        .bottom-stat i.fa-fire { color: #ef4444; }
        .bottom-stat i.fa-bullseye { color: #22c55e; }
        .bottom-stat i.fa-trophy { color: #a855f7; }

        /* Sidebar */
        .sidebar {
            position: fixed;
            right: 0;
            top: 0;
            width: 320px;
            height: 100vh;
            background: rgba(15, 13, 50, 0.95);
            border-left: 1px solid rgba(255,255,255,0.08);
            padding: 20px;
            overflow-y: auto;
        }

        .sidebar-section {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: 14px;
            padding: 18px;
            margin-bottom: 15px;
        }

        .sidebar-title {
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: rgba(255,255,255,0.5);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Profile Widget */
        .profile-widget { display: flex; align-items: center; gap: 12px; }

        .profile-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6366f1, #4f46e5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            border: 3px solid rgba(255,255,255,0.2);
        }

        .profile-info { flex: 1; }
        .profile-name { font-weight: 700; font-size: 15px; }
        .profile-level { font-size: 11px; color: rgba(255,255,255,0.5); margin-top: 2px; }

        .profile-score { text-align: right; }
        .profile-score-value { font-size: 20px; font-weight: 900; color: #f59e0b; }
        .profile-score-label { font-size: 9px; color: rgba(255,255,255,0.4); }

        /* Stats Grid */
        .stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; }

        .stat-card {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 12px;
            text-align: center;
        }

        .stat-card-value { font-size: 18px; font-weight: 800; }
        .stat-card-label { font-size: 9px; color: rgba(255,255,255,0.5); margin-top: 2px; }

        /* Activity */
        .activity-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 11px;
        }

        .activity-item:last-child { border-bottom: none; }

        .activity-icon {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .activity-text { flex: 1; color: rgba(255,255,255,0.8); }
        .activity-time { font-size: 9px; color: rgba(255,255,255,0.4); }

        /* Practice Status */
        .practice-status { display: flex; gap: 8px; flex-wrap: wrap; }

        .practice-badge {
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 10px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .practice-badge.locked { background: rgba(255,255,255,0.1); opacity: 0.5; }
        .practice-badge.unlocked { background: rgba(34, 197, 94, 0.2); border: 1px solid rgba(34, 197, 94, 0.4); }

        /* Battle Overlay */
        .battle-overlay {
            position: fixed;
            inset: 0;
            z-index: 500;
            background: rgba(0,0,0,0.92);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .battle-overlay.active { display: flex; }

        .battle-content {
            background: linear-gradient(135deg, #1e1b4b, #312e81);
            border-radius: 20px;
            padding: 25px;
            width: 100%;
            max-width: 520px;
            border: 1px solid rgba(255,255,255,0.15);
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .battle-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .battle-info { display: flex; align-items: center; gap: 12px; }
        .battle-info-icon { font-size: 32px; }
        .battle-info-name { font-size: 16px; font-weight: 700; }
        .battle-info-zone { font-size: 11px; opacity: 0.7; }

        .battle-score { text-align: right; }
        .battle-score-value { font-size: 26px; font-weight: 900; color: #f59e0b; }
        .battle-score-label { font-size: 10px; opacity: 0.5; }

        .battle-progress { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }

        .battle-streak { color: #f59e0b; font-weight: 700; font-size: 15px; }

        .battle-timer {
            background: rgba(255,255,255,0.1);
            padding: 8px 18px;
            border-radius: 20px;
            font-size: 18px;
            font-weight: 800;
            min-width: 70px;
            text-align: center;
        }

        .battle-timer.warning { background: rgba(245,158,11,0.3); color: #fbbf24; }
        .battle-timer.danger { background: rgba(239,68,68,0.4); color: #fca5a5; animation: timerBlink 0.5s infinite; }

        @keyframes timerBlink { 50% { opacity: 0.6; } }

        .battle-dots { display: flex; gap: 5px; }

        .battle-dot {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 700;
        }

        .battle-dot.active { background: #f59e0b; }
        .battle-dot.correct { background: #22c55e; }
        .battle-dot.wrong { background: #ef4444; }

        .battle-question {
            background: rgba(255,255,255,0.05);
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 18px;
        }

        .battle-question-img { max-width: 100%; max-height: 150px; border-radius: 10px; margin-bottom: 12px; display: block; }
        .battle-question-text { font-size: 16px; line-height: 1.5; }
        .battle-question-points { font-size: 11px; color: #f59e0b; margin-top: 8px; }

        .battle-options { display: flex; flex-direction: column; gap: 10px; }

        .battle-option {
            padding: 14px 16px;
            background: rgba(255,255,255,0.07);
            border: 2px solid rgba(255,255,255,0.12);
            border-radius: 10px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            text-align: left;
            display: flex;
            align-items: center;
            transition: all 0.2s;
        }

        .battle-option:hover:not(:disabled) {
            background: rgba(255,255,255,0.12);
            transform: translateX(4px);
            border-color: rgba(255,255,255,0.25);
        }

        .battle-option:disabled { cursor: default; }
        .battle-option.correct { background: rgba(34, 197, 94, 0.25); border-color: #22c55e; }
        .battle-option.wrong { background: rgba(239, 68, 68, 0.25); border-color: #ef4444; }

        .battle-option-letter {
            background: rgba(255,255,255,0.12);
            padding: 4px 10px;
            border-radius: 6px;
            margin-right: 12px;
            font-weight: 700;
            font-size: 12px;
        }

        /* Battle Result */
        .battle-result { text-align: center; padding: 15px 0; }
        .battle-result-icon { font-size: 65px; margin-bottom: 15px; }
        .battle-result-title { font-size: 26px; margin-bottom: 8px; font-weight: 800; }
        .battle-result-subtitle { opacity: 0.6; margin-bottom: 20px; font-size: 14px; }
        .battle-result-stars { font-size: 30px; color: #f59e0b; margin-bottom: 20px; }

        .battle-result-stats { display: flex; justify-content: center; gap: 25px; margin-bottom: 20px; }
        .battle-result-stat { text-align: center; }
        .battle-result-stat-value { font-size: 24px; font-weight: 900; }
        .battle-result-stat-label { font-size: 10px; opacity: 0.5; text-transform: uppercase; }

        /* ========== CELEBRACI√ìN √âPICA DE LOGROS ========== */
        
        /* Overlay de logros */
        .achievement-celebration {
            position: fixed;
            inset: 0;
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            opacity: 0;
            animation: achievementFadeIn 0.5s ease forwards;
        }
        
        @keyframes achievementFadeIn {
            to { opacity: 1; }
        }
        
        /* Confetti container */
        .achievement-confetti {
            position: absolute;
            inset: 0;
            overflow: hidden;
            pointer-events: none;
        }
        
        .confetti-piece {
            position: absolute;
            width: 12px;
            height: 12px;
            animation: confettiFall 3s ease-in-out forwards;
        }
        
        @keyframes confettiFall {
            0% { 
                transform: translateY(-100px) rotate(0deg) scale(0);
                opacity: 1;
            }
            10% { transform: translateY(0) rotate(45deg) scale(1); }
            100% { 
                transform: translateY(100vh) rotate(720deg) scale(0.5);
                opacity: 0;
            }
        }
        
        /* Card de logro principal */
        .achievement-card {
            position: relative;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 2px solid;
            border-radius: 24px;
            padding: 40px 50px;
            text-align: center;
            max-width: 380px;
            transform: scale(0) rotate(-10deg);
            animation: achievementBounceIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) 0.3s forwards;
            box-shadow: 0 25px 80px rgba(0,0,0,0.5);
        }
        
        @keyframes achievementBounceIn {
            0% { transform: scale(0) rotate(-10deg); }
            60% { transform: scale(1.1) rotate(3deg); }
            100% { transform: scale(1) rotate(0deg); }
        }
        
        /* Colores por rareza */
        .achievement-card.common { border-color: #22c55e; }
        .achievement-card.rare { border-color: #3b82f6; }
        .achievement-card.epic { border-color: #a855f7; }
        .achievement-card.legendary { 
            border-color: #f59e0b;
            animation: achievementBounceIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) 0.3s forwards,
                       legendaryGlow 2s ease-in-out infinite 0.9s;
        }
        
        @keyframes legendaryGlow {
            0%, 100% { box-shadow: 0 0 30px rgba(245, 158, 11, 0.3), 0 25px 80px rgba(0,0,0,0.5); }
            50% { box-shadow: 0 0 60px rgba(245, 158, 11, 0.6), 0 25px 80px rgba(0,0,0,0.5); }
        }
        
        /* Rayos de luz de fondo */
        .achievement-rays {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 400px;
            height: 400px;
            transform: translate(-50%, -50%);
            background: conic-gradient(
                from 0deg,
                transparent 0deg 15deg,
                rgba(255,255,255,0.03) 15deg 30deg,
                transparent 30deg 45deg,
                rgba(255,255,255,0.03) 45deg 60deg,
                transparent 60deg
            );
            animation: achievementRays 20s linear infinite;
            pointer-events: none;
        }
        
        @keyframes achievementRays {
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }
        
        /* Nuevo t√≠tulo */
        .achievement-new-label {
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            font-size: 10px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 2px;
            padding: 6px 20px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.4);
        }
        
        /* Icono del logro */
        .achievement-icon {
            font-size: 80px;
            margin-bottom: 15px;
            animation: achievementIconPop 0.5s ease 0.6s both;
            filter: drop-shadow(0 10px 20px rgba(0,0,0,0.3));
        }
        
        @keyframes achievementIconPop {
            0% { transform: scale(0); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }
        
        /* Nombre del logro */
        .achievement-name {
            font-size: 22px;
            font-weight: 800;
            color: white;
            margin-bottom: 8px;
            opacity: 0;
            animation: achievementTextIn 0.4s ease 0.8s forwards;
        }
        
        /* Descripci√≥n */
        .achievement-desc {
            font-size: 14px;
            color: rgba(255,255,255,0.6);
            margin-bottom: 20px;
            opacity: 0;
            animation: achievementTextIn 0.4s ease 0.9s forwards;
        }
        
        @keyframes achievementTextIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Badge de rareza */
        .achievement-rarity {
            display: inline-block;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0;
            animation: achievementTextIn 0.4s ease 1s forwards;
        }
        
        .achievement-rarity.common { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
        .achievement-rarity.rare { background: rgba(59, 130, 246, 0.2); color: #3b82f6; }
        .achievement-rarity.epic { background: rgba(168, 85, 247, 0.2); color: #a855f7; }
        .achievement-rarity.legendary { 
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.2), rgba(234, 88, 12, 0.2)); 
            color: #f59e0b;
        }
        
        /* Bot√≥n continuar */
        .achievement-continue {
            margin-top: 25px;
            padding: 14px 40px;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            opacity: 0;
            animation: achievementTextIn 0.4s ease 1.1s forwards;
            transition: all 0.3s;
        }
        
        .achievement-continue:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(245, 158, 11, 0.4);
        }
        
        /* Indicador de m√∫ltiples logros */
        .achievement-counter {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            opacity: 0;
            animation: achievementTextIn 0.4s ease 1.2s forwards;
        }
        
        .achievement-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            transition: all 0.3s;
        }
        
        .achievement-dot.active {
            background: #f59e0b;
            transform: scale(1.2);
        }
        
        /* Part√≠culas flotantes */
        .achievement-sparkle {
            position: absolute;
            width: 6px;
            height: 6px;
            background: white;
            border-radius: 50%;
            animation: sparkleFloat 2s ease-in-out infinite;
        }
        
        @keyframes sparkleFloat {
            0%, 100% { transform: translateY(0) scale(1); opacity: 0.5; }
            50% { transform: translateY(-20px) scale(1.5); opacity: 1; }
        }

        /* ========== FIN CELEBRACI√ìN DE LOGROS ========== */

        .new-achievements {
            background: rgba(168, 85, 247, 0.15);
            border: 1px solid rgba(168, 85, 247, 0.3);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .new-achievement-title { font-size: 11px; text-transform: uppercase; color: #a855f7; margin-bottom: 10px; font-weight: 700; }

        .new-achievement-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            margin-bottom: 6px;
        }

        .battle-btn {
            padding: 14px 45px;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
        }

        .battle-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(245, 158, 11, 0.4); }

        /* Cooldown */
        .cooldown-overlay {
            position: fixed;
            inset: 0;
            z-index: 600;
            background: linear-gradient(135deg, #1e1b4b, #312e81);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 40px;
        }

        .cooldown-overlay.active { display: flex; }

        .cooldown-icon { font-size: 70px; margin-bottom: 20px; animation: cooldownFloat 3s ease-in-out infinite; }

        @keyframes cooldownFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .cooldown-title { font-size: 26px; margin-bottom: 10px; }
        .cooldown-subtitle { opacity: 0.6; margin-bottom: 25px; font-size: 14px; }

        .cooldown-timer { display: flex; gap: 12px; margin-bottom: 25px; }
        .cooldown-unit { text-align: center; }
        .cooldown-value { font-size: 42px; font-weight: 900; color: #f59e0b; display: block; }
        .cooldown-label { font-size: 10px; opacity: 0.5; text-transform: uppercase; }
        .cooldown-sep { font-size: 42px; opacity: 0.3; }

        .cooldown-btn {
            padding: 14px 35px;
            background: linear-gradient(135deg, #6366f1, #4f46e5);
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: 700;
            cursor: pointer;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        /* Cinematic Overlay */
        .cinematic-overlay {
            position: fixed;
            inset: 0;
            z-index: 700;
            background: rgba(0,0,0,0.95);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 40px;
        }

        .cinematic-overlay.active { display: flex; }

        .cinematic-content {
            max-width: 600px;
            text-align: center;
            animation: cinematicFadeIn 0.8s ease-out;
        }

        @keyframes cinematicFadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .cinematic-icon { font-size: 80px; margin-bottom: 20px; animation: cinematicBounce 1s ease-in-out infinite; }

        @keyframes cinematicBounce {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .cinematic-title { font-size: 32px; font-weight: 900; margin-bottom: 15px; }
        .cinematic-text { font-size: 16px; opacity: 0.8; line-height: 1.6; margin-bottom: 30px; }

        .cinematic-btn {
            padding: 15px 50px;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
        }

        /* Floating Points */
        .float-points {
            position: fixed;
            z-index: 9999;
            font-size: 28px;
            font-weight: 900;
            color: #f59e0b;
            text-shadow: 0 0 20px rgba(245, 158, 11, 0.6);
            pointer-events: none;
            animation: pointsFloat 1.3s ease-out forwards;
        }

        @keyframes pointsFloat {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-70px) scale(1.2); }
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 27, 75, 0.95);
            border: 1px solid rgba(255,255,255,0.15);
            padding: 12px 25px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            z-index: 800;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: toastIn 0.3s ease-out;
        }

        @keyframes toastIn {
            from { opacity: 0; transform: translateX(-50%) translateY(20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .header { right: 0; }
            .map-container { right: 0; }
            .bottom-panel { right: 20px; }
            .sidebar { display: none; }
        }

        @media (max-width: 600px) {
            .node-inner { width: 45px; height: 45px; font-size: 18px; }
            .node.boss .node-inner { width: 55px; height: 55px; }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-left">
            <a href="quiz.html" class="back-btn"><i class="fas fa-arrow-left"></i> Voltar</a>
            <h1 class="title" id="mapTitle">Reino do Conhecimento</h1>
        </div>
        <div class="header-stats" id="headerStats"></div>
    </header>

    <!-- Map -->
    <div class="map-container">
        <div class="map" id="map">
            <svg class="routes" id="routes"></svg>
            <div class="nodes" id="nodes"></div>
            <!-- Part√≠culas de ambiente -->
            <div class="zone-particles" id="zoneParticles"></div>
        </div>
    </div>

    <!-- Efecto de rasgadura para Boss -->
    <div class="boss-slash-effect" id="bossSlashEffect" style="display:none;">
        <div class="boss-slash"></div>
        <div class="boss-slash"></div>
        <div class="boss-slash"></div>
    </div>

    <!-- Bottom Panel -->
    <div class="bottom-panel" id="bottomPanel"></div>

    <!-- Sidebar -->
    <aside class="sidebar">
        <div class="sidebar-section" id="profileSection"></div>
        <div class="sidebar-section" id="statsSection"></div>
        <div class="sidebar-section" id="practiceSection"></div>
        <div class="sidebar-section" id="activitySection"></div>
    </aside>

    <!-- Battle Overlay -->
    <div class="battle-overlay" id="battleOverlay">
        <div class="battle-content" id="battleContent"></div>
    </div>

    <!-- Cooldown Overlay -->
    <div class="cooldown-overlay" id="cooldownOverlay">
        <div class="cooldown-icon">üò¥</div>
        <h2 class="cooldown-title">Descansando...</h2>
        <p class="cooldown-subtitle">Voc√™ perdeu todas as vidas. Espere para continuar.</p>
        <div class="cooldown-timer">
            <div class="cooldown-unit"><span class="cooldown-value" id="cdH">00</span><span class="cooldown-label">Horas</span></div>
            <span class="cooldown-sep">:</span>
            <div class="cooldown-unit"><span class="cooldown-value" id="cdM">00</span><span class="cooldown-label">Min</span></div>
            <span class="cooldown-sep">:</span>
            <div class="cooldown-unit"><span class="cooldown-value" id="cdS">00</span><span class="cooldown-label">Seg</span></div>
        </div>
        <a href="quiz.html" class="cooldown-btn"><i class="fas fa-gamepad"></i> Modo Pr√°tica</a>
    </div>

    <!-- Cinematic Overlay -->
    <div class="cinematic-overlay" id="cinematicOverlay">
        <div class="cinematic-content" id="cinematicContent"></div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="js/config.js"></script>
    <script src="js/modules/utils.js"></script>
    <script src="js/modules/storage.js"></script>
    <script src="js/quiz/data.js"></script>
    <script src="js/quiz/profile.js"></script>
    <script src="js/quiz/achievements.js"></script>
    <script src="js/quiz/ranking.js"></script>
    <script src="js/quiz/activity.js"></script>

    <script>
    // ============================================
    // CAMPAIGN v12 - Estado por Usuario + Integraci√≥n con Quiz Config
    // ============================================

    // Storage Keys (Unificadas)
    const KEYS = {
        quizConfig: 'cartoesx_admin_config',      // Config del Quiz (principal)
        campaignConfig: 'cartoesx_campaign_config', // Config extra de Campa√±a
        maps: 'cartoesx_campaign_maps',
        questions: 'cartoesx_quiz_questions',
        profiles: 'cartoesx_quiz_profiles',
        current: 'cartoesx_quiz_current_profile'
    };

    // ============================================
    // CONFIG UNIFICADA (Lee del Quiz + valores de Campa√±a)
    // ============================================
    function getUnifiedConfig() {
        // Leer config del Quiz (donde se definen puntos por nivel)
        let quizConfig = {};
        try {
            const saved = localStorage.getItem(KEYS.quizConfig);
            if (saved) {
                quizConfig = JSON.parse(saved);
            }
        } catch (e) {
            console.error('Error loading quiz config:', e);
        }

        // Leer config extra de campa√±a
        let campaignConfig = {};
        try {
            const saved = localStorage.getItem(KEYS.campaignConfig);
            if (saved) campaignConfig = JSON.parse(saved);
        } catch (e) {}

        // Valores por defecto (puntos premium)
        const defaults = {
            points: { facil: 100, media: 150, dificil: 200, avancado: 250 },
            time: { facil: 30, media: 25, dificil: 20, avancado: 15 },
            shuffleQuestions: true,
            shuffleAnswers: true,
            questionsPerGame: 10,
            questionsPerBattle: 3,
            maxLives: 2,
            cooldownHours: 8,
            streakBonus: 25,
            timeBonus: 5,
            perfectBonus: 150,
            zoneMultipliers: [1, 1.5, 2, 3]
        };

        // Construir puntos: prioridad Quiz Config > Defaults
        const finalPoints = {
            facil: (quizConfig.points && quizConfig.points.facil) ? quizConfig.points.facil : defaults.points.facil,
            media: (quizConfig.points && quizConfig.points.media) ? quizConfig.points.media : defaults.points.media,
            dificil: (quizConfig.points && quizConfig.points.dificil) ? quizConfig.points.dificil : defaults.points.dificil,
            avancado: (quizConfig.points && quizConfig.points.avancado) ? quizConfig.points.avancado : defaults.points.avancado
        };

        const finalTime = {
            facil: (quizConfig.time && quizConfig.time.facil) ? quizConfig.time.facil : defaults.time.facil,
            media: (quizConfig.time && quizConfig.time.media) ? quizConfig.time.media : defaults.time.media,
            dificil: (quizConfig.time && quizConfig.time.dificil) ? quizConfig.time.dificil : defaults.time.dificil,
            avancado: (quizConfig.time && quizConfig.time.avancado) ? quizConfig.time.avancado : defaults.time.avancado
        };

        return {
            points: finalPoints,
            time: finalTime,
            shuffleQuestions: quizConfig.shuffleQuestions !== undefined ? quizConfig.shuffleQuestions : defaults.shuffleQuestions,
            shuffleAnswers: quizConfig.shuffleAnswers !== undefined ? quizConfig.shuffleAnswers : defaults.shuffleAnswers,
            questionsPerGame: quizConfig.questionsPerGame || defaults.questionsPerGame,
            questionsPerBattle: campaignConfig.questionsPerBattle || defaults.questionsPerBattle,
            maxLives: campaignConfig.maxLives || defaults.maxLives,
            cooldownHours: campaignConfig.cooldownHours || defaults.cooldownHours,
            streakBonus: campaignConfig.streakBonus || defaults.streakBonus,
            timeBonus: campaignConfig.timeBonus || defaults.timeBonus,
            perfectBonus: campaignConfig.perfectBonus || defaults.perfectBonus,
            zoneMultipliers: campaignConfig.zoneMultipliers || defaults.zoneMultipliers
        };
    }

    // ============================================
    // DEFAULT MAP - TEM√ÅTICA AEROPUERTO VIP
    // ============================================
    const DEFAULT_MAP = {
        name: 'Aeroporto Premium',
        background: 'https://images.unsplash.com/photo-1436491865332-7a61a109cc05?w=1200&h=800&fit=crop',
        zones: [
            {
                id: 0,
                name: 'Terminal B√°sico',
                color: '#22c55e',
                difficulty: 'facil',
                icon: 'üõ´',
                nodes: [
                    { id: 0, x: 8, y: 75, name: 'Check-in', icon: 'üé´', type: 'start' },
                    { id: 1, x: 22, y: 58, name: 'Seguran√ßa', icon: 'üõ°Ô∏è', type: 'battle' },
                    { id: 2, x: 38, y: 70, name: 'Duty Free', icon: 'üõçÔ∏è', type: 'treasure' },
                    { id: 3, x: 52, y: 52, name: 'Port√£o de Embarque', icon: '‚úàÔ∏è', type: 'boss' }
                ],
                routes: [[0,1], [1,2], [2,3]]
            },
            {
                id: 1,
                name: 'Lounge VIP',
                color: '#f59e0b',
                difficulty: 'media',
                icon: 'ü•Ç',
                nodes: [
                    { id: 4, x: 60, y: 38, name: 'Recep√ß√£o VIP', icon: 'üé©', type: 'checkpoint' },
                    { id: 5, x: 72, y: 28, name: 'Bar Premium', icon: 'üçæ', type: 'battle' },
                    { id: 6, x: 82, y: 42, name: 'Spa & Descanso', icon: 'üíÜ', type: 'mystery' },
                    { id: 7, x: 88, y: 55, name: 'Concierge', icon: 'üëî', type: 'boss' }
                ],
                routes: [[3,4], [4,5], [5,6], [6,7]]
            },
            {
                id: 2,
                name: 'First Class',
                color: '#a855f7',
                difficulty: 'dificil',
                icon: 'üíé',
                nodes: [
                    { id: 8, x: 78, y: 68, name: 'Suite Privada', icon: 'üõãÔ∏è', type: 'battle' },
                    { id: 9, x: 85, y: 80, name: 'Chef Particular', icon: 'üë®‚Äçüç≥', type: 'treasure' },
                    { id: 10, x: 92, y: 88, name: 'Black Card', icon: 'üí≥', type: 'final' }
                ],
                routes: [[7,8], [8,9], [9,10]]
            }
        ]
    };

    // ============================================
    // DEFAULT QUESTIONS
    // ============================================
    const DEFAULT_QUESTIONS = [
        { question: "Qual programa de milhas pertence √† GOL?", options: ["Latam Pass", "Smiles", "TudoAzul", "Livelo"], correct: 1, diff: "facil", points: 100, active: true },
        { question: "O que significa cashback?", options: ["Desconto", "Dinheiro de volta", "Pontos", "Milhas"], correct: 1, diff: "facil", points: 100, active: true },
        { question: "Qual a vantagem de cart√µes platinum?", options: ["Cor diferente", "Mais limite", "Benef√≠cios extras", "Taxa menor"], correct: 2, diff: "facil", points: 100, active: true },
        { question: "O que significa anuidade?", options: ["Taxa mensal", "Taxa anual", "Juros", "Multa"], correct: 1, diff: "facil", points: 100, active: true },
        { question: "Quantas milhas para voo dom√©stico b√°sico?", options: ["5.000", "10.000", "15.000", "20.000"], correct: 1, diff: "facil", points: 100, active: true },
        { question: "Melhor √©poca para resgatar milhas?", options: ["Alta temporada", "Baixa temporada", "Feriados", "Natal"], correct: 1, diff: "media", points: 150, active: true },
        { question: "O que √© cart√£o co-branded?", options: ["Internacional", "Parceria com empresa", "Virtual", "Premium"], correct: 1, diff: "media", points: 150, active: true },
        { question: "Prazo m√©dio de validade das milhas?", options: ["6 meses", "1 ano", "2 anos", "Nunca expiram"], correct: 2, diff: "media", points: 150, active: true },
        { question: "Star Alliance inclui qual companhia?", options: ["Latam", "Gol", "Avianca", "Azul"], correct: 2, diff: "dificil", points: 200, active: true },
        { question: "O que √© stopover?", options: ["Escala curta", "Parada longa >24h", "Conex√£o", "Voo direto"], correct: 1, diff: "dificil", points: 200, active: true }
    ];

    // ============================================
    // CINEMATIC DATA
    // ============================================
    const CINEMATICS = {
        welcome: {
            icon: 'üè∞',
            title: 'Bem-vindo ao Reino!',
            text: 'Voc√™ est√° prestes a embarcar em uma jornada √©pica pelo Reino do Conhecimento. Complete desafios, conquiste territ√≥rios e torne-se o mestre dos cart√µes de cr√©dito!',
            button: 'Come√ßar Aventura'
        },
        zone_complete: {
            icon: '‚≠ê',
            title: 'Zona Conquistada!',
            text: 'Parab√©ns! Voc√™ dominou esta regi√£o e provou seu conhecimento. Novas terras aguardam por voc√™!',
            button: 'Continuar'
        },
        all_complete: {
            icon: 'üëë',
            title: 'MESTRE DO REINO!',
            text: 'Incr√≠vel! Voc√™ conquistou todo o Reino do Conhecimento! Voc√™ √© verdadeiramente um especialista em cart√µes de cr√©dito!',
            button: 'Celebrar!'
        }
    };

    // ============================================
    // STATE MANAGEMENT (PER USER)
    // ============================================
    let config = {};  // Se cargar√° con getUnifiedConfig()
    let mapData = { ...DEFAULT_MAP };
    let currentUserId = null;

    // Estado vac√≠o para nuevo usuario
    function getEmptyState() {
        const cfg = config.maxLives ? config : getUnifiedConfig();
        return {
            lives: cfg.maxLives || 2,
            maxLives: cfg.maxLives || 2,
            cooldownUntil: null,
            unlockedNodes: [0],
            completedNodes: [],
            nodeStars: {},
            totalScore: 0,
            bestStreak: 0,
            totalCorrect: 0,
            totalWrong: 0,
            totalBattles: 0,
            unlockedPractice: { facil: false, media: false, dificil: false },
            newAchievements: []
        };
    }

    let state = null; // Se inicializar√° despu√©s de cargar config

    // Obtener key de estado por usuario
    function getStateKey(userId) {
        return `cartoesx_campaign_state_${userId || 'guest'}`;
    }

    // Cargar estado del usuario actual
    function loadUserState() {
        // Detectar usuario actual
        const currentProfile = JSON.parse(localStorage.getItem(KEYS.current) || 'null');
        currentUserId = currentProfile?.id || 'guest';

        // Cargar estado de ese usuario
        const key = getStateKey(currentUserId);
        const saved = localStorage.getItem(key);
        
        if (saved) {
            try {
                state = { ...getEmptyState(), ...JSON.parse(saved) };
            } catch (e) {
                state = getEmptyState();
            }
        } else {
            state = getEmptyState();
        }

        console.log(`‚úì State loaded for user: ${currentUserId}`);
    }

    // Guardar estado del usuario actual
    function saveUserState() {
        const key = getStateKey(currentUserId);
        localStorage.setItem(key, JSON.stringify(state));
    }

    // Cargar configuraci√≥n (Unificada desde Quiz + Campaign)
    function loadConfig() {
        config = getUnifiedConfig();
        console.log('‚úì Config unificada cargada:', config);
    }

    // Cargar mapa (desde Admin)
    function loadMap() {
        try {
            const saved = localStorage.getItem(KEYS.maps);
            if (saved) {
                const maps = JSON.parse(saved);
                if (maps && maps.length > 0 && maps[0].zones) {
                    mapData = { ...DEFAULT_MAP, ...maps[0] };
                }
            }
        } catch (e) {}
    }

    // Cargar preguntas
    function getQuestions() {
        try {
            const saved = localStorage.getItem(KEYS.questions);
            if (saved) {
                const q = JSON.parse(saved);
                if (q && q.length > 0) return q.filter(x => x.active !== false);
            }
        } catch (e) {}
        return DEFAULT_QUESTIONS;
    }

    // ============================================
    // HELPER FUNCTIONS
    // ============================================
    function getAllNodes() {
        let nodes = [];
        mapData.zones.forEach(zone => {
            zone.nodes.forEach(n => {
                nodes.push({ ...n, zoneId: zone.id, zoneColor: zone.color, zoneName: zone.name, difficulty: zone.difficulty });
            });
        });
        return nodes;
    }

    function getAllRoutes() {
        let routes = [];
        mapData.zones.forEach(zone => {
            zone.routes.forEach(r => routes.push({ from: r[0], to: r[1], color: zone.color }));
        });
        return routes;
    }

    function getNodeById(id) { return getAllNodes().find(n => n.id === id); }
    function isUnlocked(id) { return state.unlockedNodes.includes(id); }
    function isCompleted(id) { return state.completedNodes.includes(id); }
    function getStars(id) { return state.nodeStars[id] || 0; }

    // Fisher-Yates Shuffle (igual que en QuizRules)
    function shuffle(arr) {
        const a = [...arr];
        for (let i = a.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
    }

    // Shuffle de pregunta con respuestas (mantiene coherencia del √≠ndice correcto)
    function shuffleQuestionWithAnswers(question) {
        if (!config.shuffleAnswers) return question;

        // Crear array de respuestas con √≠ndice original
        const answers = question.options.map((text, index) => ({
            text,
            originalIndex: index,
            isCorrect: index === question.correct
        }));

        // Mezclar con Fisher-Yates
        const shuffled = shuffle(answers);

        // Encontrar nuevo √≠ndice de la respuesta correcta
        const newCorrectIndex = shuffled.findIndex(a => a.isCorrect);

        return {
            ...question,
            options: shuffled.map(a => a.text),
            correct: newCorrectIndex
        };
    }

    // Preparar preguntas para batalla (shuffle + shuffle respuestas)
    function prepareQuestionsForBattle(questions) {
        let prepared = [...questions];
        
        // Shuffle de preguntas si est√° habilitado
        if (config.shuffleQuestions) {
            prepared = shuffle(prepared);
        }

        // Shuffle de respuestas en cada pregunta si est√° habilitado
        if (config.shuffleAnswers) {
            prepared = prepared.map(q => shuffleQuestionWithAnswers(q));
        }

        return prepared;
    }

    function formatTimeAgo(date) {
        const s = Math.floor((new Date() - new Date(date)) / 1000);
        if (s < 60) return 'agora';
        if (s < 3600) return Math.floor(s / 60) + 'min';
        if (s < 86400) return Math.floor(s / 3600) + 'h';
        return Math.floor(s / 86400) + 'd';
    }

    // ============================================
    // COOLDOWN SYSTEM
    // ============================================
    let cooldownInterval = null;

    function checkCooldown() {
        if (state.cooldownUntil) {
            if (new Date() >= new Date(state.cooldownUntil)) {
                state.cooldownUntil = null;
                state.lives = state.maxLives;
                saveUserState();
                return false;
            }
            return true;
        }
        return false;
    }

    function getCooldownRemaining() {
        if (!state.cooldownUntil) return null;
        const remaining = new Date(state.cooldownUntil) - new Date();
        if (remaining <= 0) return null;
        return {
            h: Math.floor(remaining / 3600000),
            m: Math.floor((remaining % 3600000) / 60000),
            s: Math.floor((remaining % 60000) / 1000)
        };
    }

    function showCooldown() {
        document.getElementById('cooldownOverlay').classList.add('active');
        updateCooldownDisplay();
        clearInterval(cooldownInterval);
        cooldownInterval = setInterval(() => {
            if (!getCooldownRemaining()) {
                document.getElementById('cooldownOverlay').classList.remove('active');
                clearInterval(cooldownInterval);
                renderAll();
            } else {
                updateCooldownDisplay();
            }
        }, 1000);
    }

    function updateCooldownDisplay() {
        const rem = getCooldownRemaining();
        if (!rem) return;
        document.getElementById('cdH').textContent = String(rem.h).padStart(2, '0');
        document.getElementById('cdM').textContent = String(rem.m).padStart(2, '0');
        document.getElementById('cdS').textContent = String(rem.s).padStart(2, '0');
    }

    // ============================================
    // CINEMATIC SYSTEM
    // ============================================
    function showCinematic(type, callback) {
        const cine = CINEMATICS[type];
        if (!cine) {
            if (callback) callback();
            return;
        }

        document.getElementById('cinematicContent').innerHTML = `
            <div class="cinematic-icon">${cine.icon}</div>
            <h1 class="cinematic-title">${cine.title}</h1>
            <p class="cinematic-text">${cine.text}</p>
            <button class="cinematic-btn" onclick="closeCinematic()">${cine.button}</button>
        `;
        document.getElementById('cinematicOverlay').classList.add('active');

        window.closeCinematic = () => {
            document.getElementById('cinematicOverlay').classList.remove('active');
            if (callback) callback();
        };
    }

    // ============================================
    // RENDER FUNCTIONS
    // ============================================
    function renderAll() {
        renderHeader();
        renderMap();
        renderBottomPanel();
        renderSidebar();
    }

    function renderHeader() {
        let hearts = '';
        for (let i = 0; i < state.maxLives; i++) {
            hearts += `<span class="heart ${i >= state.lives ? 'lost' : ''}">‚ù§Ô∏è</span>`;
        }

        const zoneIndex = Math.min(Math.floor(state.completedNodes.length / 3), mapData.zones.length - 1);
        const zone = mapData.zones[zoneIndex];

        document.getElementById('headerStats').innerHTML = `
            <div class="stat-pill">${hearts}</div>
            <div class="stat-pill" style="background:${zone.color}22;border:1px solid ${zone.color}55;">
                <span>${zone.icon || 'üó∫Ô∏è'}</span> ${zone.name}
            </div>
        `;

        document.getElementById('mapTitle').textContent = mapData.name;
        document.getElementById('map').style.backgroundImage = `url('${mapData.background}')`;
    }

    function renderMap() {
        const routes = getAllRoutes();
        const nodes = getAllNodes();

        // Routes
        let routesHTML = '';
        routes.forEach(r => {
            const from = nodes.find(n => n.id === r.from);
            const to = nodes.find(n => n.id === r.to);
            if (from && to) {
                const completed = isCompleted(r.from) && isCompleted(r.to);
                const active = isCompleted(r.from) && !isCompleted(r.to) && isUnlocked(r.to);
                routesHTML += `<line class="route ${completed?'completed':''} ${active?'active':''}" 
                    x1="${from.x}%" y1="${from.y}%" x2="${to.x}%" y2="${to.y}%" style="stroke:${r.color}"/>`;
            }
        });
        document.getElementById('routes').innerHTML = routesHTML;

        // Nodes con efectos por tipo
        let nodesHTML = '';
        const lastUnlocked = state.unlockedNodes[state.unlockedNodes.length - 1];

        nodes.forEach(node => {
            const unlocked = isUnlocked(node.id);
            const completed = isCompleted(node.id);
            const stars = getStars(node.id);
            const isCurrent = unlocked && !completed && node.id === lastUnlocked;
            const nodeType = node.type || 'battle';
            const isBoss = nodeType === 'boss' || nodeType === 'final';

            let status = 'locked';
            if (completed) status = 'completed';
            else if (isCurrent) status = 'current';
            else if (unlocked) status = 'unlocked';

            nodesHTML += `
                <div class="node ${status} ${isBoss ? 'boss' : ''}" 
                     data-type="${nodeType}"
                     data-id="${node.id}"
                     onclick="handleNodeClick(${node.id})" 
                     style="left:${node.x}%;top:${node.y}%;">
                    <div class="node-inner" style="background: linear-gradient(135deg, ${node.zoneColor}, ${adjustColor(node.zoneColor, -20)});">${node.icon}</div>
                    <span class="node-label">${node.name}</span>
                    ${completed ? `
                        <div class="node-check"><i class="fas fa-check"></i></div>
                        <div class="node-stars">${'‚òÖ'.repeat(stars)}${'‚òÜ'.repeat(3-stars)}</div>
                    ` : ''}
                </div>
            `;
        });
        document.getElementById('nodes').innerHTML = nodesHTML;
        
        // Agregar part√≠culas de zona
        renderZoneParticles();
    }

    // Funci√≥n para ajustar brillo del color
    function adjustColor(hex, amount) {
        if (!hex) return '#4b5563';
        const num = parseInt(hex.replace('#', ''), 16);
        const r = Math.min(255, Math.max(0, (num >> 16) + amount));
        const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amount));
        const b = Math.min(255, Math.max(0, (num & 0x0000FF) + amount));
        return '#' + (0x1000000 + r * 0x10000 + g * 0x100 + b).toString(16).slice(1);
    }

    // Part√≠culas de ambiente seg√∫n zona actual
    function renderZoneParticles() {
        const particlesContainer = document.getElementById('zoneParticles');
        if (!particlesContainer) return;
        
        // Determinar zona actual basada en el √∫ltimo nodo
        const lastUnlocked = state.unlockedNodes[state.unlockedNodes.length - 1];
        const currentNode = getAllNodes().find(n => n.id === lastUnlocked);
        const difficulty = currentNode?.difficulty || 'facil';
        
        // Part√≠culas tem√°ticas VIP/Aeropuerto
        const particles = {
            facil: { emoji: '‚úàÔ∏è', count: 6 },      // Terminal - aviones
            media: { emoji: 'ü•Ç', count: 8 },      // Lounge VIP - champagne
            dificil: { emoji: 'üíé', count: 10 },   // First Class - diamantes
            avancado: { emoji: 'üí≥', count: 12 }   // Black Card - tarjetas
        };
        
        const p = particles[difficulty] || particles.facil;
        let html = '';
        for (let i = 0; i < p.count; i++) {
            const left = Math.random() * 100;
            const delay = Math.random() * 8;
            const size = 14 + Math.random() * 12;
            html += `<div class="particle" style="left:${left}%;font-size:${size}px;animation-delay:${delay}s;">${p.emoji}</div>`;
        }
        particlesContainer.innerHTML = html;
    }

    function renderBottomPanel() {
        const totalStars = Object.values(state.nodeStars).reduce((a,b) => a+b, 0);
        const maxStars = getAllNodes().length * 3;
        const total = state.totalCorrect + state.totalWrong;
        const accuracy = total > 0 ? Math.round((state.totalCorrect / total) * 100) : 0;

        document.getElementById('bottomPanel').innerHTML = `
            <div class="bottom-stat"><i class="fas fa-star"></i> ${totalStars}/${maxStars}</div>
            <div class="bottom-stat"><i class="fas fa-fire"></i> ${state.bestStreak}</div>
            <div class="bottom-stat"><i class="fas fa-bullseye"></i> ${accuracy}%</div>
            <div class="bottom-stat"><i class="fas fa-trophy"></i> ${state.totalScore} pts</div>
        `;
    }

    function renderSidebar() {
        renderProfile();
        renderStats();
        renderPractice();
        renderActivity();
    }

    function renderProfile() {
        let username = 'Jogador';
        let avatarIcon = 'üéÆ';
        let level = 1;

        if (typeof QuizProfile !== 'undefined' && QuizProfile.current) {
            username = QuizProfile.current.username || username;
            if (typeof QuizData !== 'undefined') {
                const av = QuizData.getAvatar?.(QuizProfile.current.avatar);
                avatarIcon = av?.icon || avatarIcon;
            }
            level = Math.floor((state.totalScore || 0) / 500) + 1;
        }

        const zoneIndex = Math.min(Math.floor(state.completedNodes.length / 3), mapData.zones.length - 1);

        document.getElementById('profileSection').innerHTML = `
            <div class="profile-widget">
                <div class="profile-avatar">${avatarIcon}</div>
                <div class="profile-info">
                    <div class="profile-name">${username}</div>
                    <div class="profile-level">N√≠vel ${level} ‚Ä¢ ${mapData.zones[zoneIndex].name}</div>
                </div>
                <div class="profile-score">
                    <div class="profile-score-value">${state.totalScore}</div>
                    <div class="profile-score-label">pontos</div>
                </div>
            </div>
        `;
    }

    function renderStats() {
        const totalStars = Object.values(state.nodeStars).reduce((a,b) => a+b, 0);
        const completed = state.completedNodes.length;
        const total = getAllNodes().length;
        const accuracy = (state.totalCorrect + state.totalWrong) > 0 
            ? Math.round((state.totalCorrect / (state.totalCorrect + state.totalWrong)) * 100) : 0;

        document.getElementById('statsSection').innerHTML = `
            <div class="sidebar-title"><i class="fas fa-chart-bar"></i> Estat√≠sticas</div>
            <div class="stats-grid">
                <div class="stat-card"><div class="stat-card-value" style="color:#f59e0b;">‚≠ê ${totalStars}</div><div class="stat-card-label">Estrelas</div></div>
                <div class="stat-card"><div class="stat-card-value" style="color:#22c55e;">${completed}/${total}</div><div class="stat-card-label">N√≥s</div></div>
                <div class="stat-card"><div class="stat-card-value" style="color:#ef4444;">üî• ${state.bestStreak}</div><div class="stat-card-label">Melhor Racha</div></div>
                <div class="stat-card"><div class="stat-card-value" style="color:#3b82f6;">${accuracy}%</div><div class="stat-card-label">Precis√£o</div></div>
            </div>
        `;
    }

    function renderPractice() {
        const levels = [
            { key: 'facil', name: 'F√°cil', color: '#22c55e' },
            { key: 'media', name: 'M√©dio', color: '#f59e0b' },
            { key: 'dificil', name: 'Dif√≠cil', color: '#ef4444' }
        ];

        let badges = levels.map(l => {
            const unlocked = state.unlockedPractice[l.key];
            return `<div class="practice-badge ${unlocked ? 'unlocked' : 'locked'}">
                ${unlocked ? '<i class="fas fa-check"></i>' : '<i class="fas fa-lock"></i>'} ${l.name}
            </div>`;
        }).join('');

        document.getElementById('practiceSection').innerHTML = `
            <div class="sidebar-title"><i class="fas fa-book"></i> Modo Pr√°tica</div>
            <div class="practice-status">${badges}</div>
            <p style="font-size:9px;color:rgba(255,255,255,0.4);margin-top:8px;">
                Inicie uma batalha na zona para desbloquear.
            </p>
        `;
    }

    function renderActivity() {
        let activities = [];
        if (typeof QuizActivity !== 'undefined') {
            activities = QuizActivity.getFeed?.()?.slice(0, 4) || [];
        }

        let html = '';
        if (activities.length === 0) {
            html = '<p style="font-size:11px;opacity:0.5;">Sem atividade ainda.</p>';
        } else {
            activities.forEach(a => {
                const icon = a.type === 'game' ? 'üéÆ' : a.type === 'achievement' ? 'üèÜ' : '‚≠ê';
                html += `
                    <div class="activity-item">
                        <div class="activity-icon">${icon}</div>
                        <div class="activity-text">${a.text || a.message || ''}</div>
                        <div class="activity-time">${formatTimeAgo(a.date || a.timestamp)}</div>
                    </div>
                `;
            });
        }

        document.getElementById('activitySection').innerHTML = `
            <div class="sidebar-title"><i class="fas fa-clock"></i> Atividade</div>
            ${html}
        `;
    }

    // ============================================
    // NODE CLICK HANDLER
    // ============================================
    function handleNodeClick(nodeId) {
        if (!isUnlocked(nodeId)) {
            showToast('üîí N√≥ bloqueado!');
            return;
        }
        if (isCompleted(nodeId)) {
            showToast('‚úÖ J√° conquistado!');
            return;
        }
        if (checkCooldown()) {
            showCooldown();
            return;
        }
        startBattle(nodeId);
    }

    // ============================================
    // BATTLE SYSTEM
    // ============================================
    let battle = {
        active: false,
        nodeId: null,
        questions: [],
        currentIndex: 0,
        score: 0,
        correct: 0,
        wrong: 0,
        streak: 0,
        maxStreak: 0,
        startTime: null,
        questionStartTime: null,
        answers: []
    };

    let battleTimer = null;
    let timeLeft = 30;

    function startBattle(nodeId) {
        const node = getNodeById(nodeId);
        const allQ = getQuestions();
        const isBoss = node.type === 'boss' || node.type === 'final';

        // Efecto especial para boss
        if (isBoss) {
            showBossSlashEffect();
        }

        // Filter by difficulty (no incluir 'avancado' - solo en eventos especiales)
        let filtered = allQ.filter(q => q.diff === node.difficulty && q.diff !== 'avancado');
        if (filtered.length < config.questionsPerBattle) {
            // Si no hay suficientes, usar todas excepto avanzadas
            filtered = allQ.filter(q => q.diff !== 'avancado');
        }

        // Preparar preguntas con shuffle de preguntas y respuestas seg√∫n config
        const questions = prepareQuestionsForBattle(filtered).slice(0, config.questionsPerBattle);

        if (questions.length < config.questionsPerBattle) {
            showToast('‚ùå Sem perguntas suficientes!');
            return;
        }

        state.newAchievements = [];

        battle = {
            active: true,
            nodeId: nodeId,
            nodeType: node.type,
            difficulty: node.difficulty, // Guardar dificultad para desbloqueo
            questions: questions,
            currentIndex: 0,
            score: 0,
            correct: 0,
            wrong: 0,
            streak: 0,
            maxStreak: 0,
            startTime: Date.now(),
            questionStartTime: null,
            answers: [],
            practiceUnlocked: false // Flag para saber si ya se desbloque√≥ en esta batalla
        };

        // Delay para boss (mostrar efecto primero)
        const delay = isBoss ? 600 : 0;
        setTimeout(() => {
            document.getElementById('battleOverlay').classList.add('active');
            showQuestion();
        }, delay);
    }

    // Efecto de rasgadura para boss
    function showBossSlashEffect() {
        const effect = document.getElementById('bossSlashEffect');
        if (effect) {
            effect.style.display = 'block';
            // Sonido opcional (vibraci√≥n en m√≥vil)
            if (navigator.vibrate) navigator.vibrate([100, 50, 100]);
            
            setTimeout(() => {
                effect.style.display = 'none';
            }, 800);
        }
    }

    function showQuestion() {
        const q = battle.questions[battle.currentIndex];
        const node = getNodeById(battle.nodeId);
        const difficulty = q.diff || battle.difficulty || 'facil';

        battle.questionStartTime = Date.now();
        // Usar tiempo seg√∫n dificultad de la pregunta (de la config del Quiz)
        timeLeft = config.time[difficulty] || config.time.facil || 30;

        // Dots
        let dots = '';
        for (let i = 0; i < config.questionsPerBattle; i++) {
            if (i < battle.answers.length) {
                dots += `<div class="battle-dot ${battle.answers[i].correct ? 'correct' : 'wrong'}">${battle.answers[i].correct ? '‚úì' : '‚úó'}</div>`;
            } else if (i === battle.currentIndex) {
                dots += `<div class="battle-dot active">${i + 1}</div>`;
            } else {
                dots += `<div class="battle-dot">${i + 1}</div>`;
            }
        }

        // Question points (from config by difficulty, or from question if custom)
        const questionPoints = q.points || config.points[difficulty] || config.points.facil || 100;

        document.getElementById('battleContent').innerHTML = `
            <div class="battle-header">
                <div class="battle-info">
                    <span class="battle-info-icon">${node.icon}</span>
                    <div>
                        <div class="battle-info-name">${node.name}</div>
                        <div class="battle-info-zone" style="color:${node.zoneColor}">${node.zoneName}</div>
                    </div>
                </div>
                <div class="battle-score">
                    <div class="battle-score-value" id="scoreValue">${battle.score}</div>
                    <div class="battle-score-label">pontos</div>
                </div>
            </div>

            <div class="battle-progress">
                <div class="battle-streak"><i class="fas fa-fire"></i> ${battle.streak}x</div>
                <div class="battle-timer" id="timer">${timeLeft}s</div>
                <div class="battle-dots">${dots}</div>
            </div>

            <div class="battle-question">
                ${q.image ? `<img src="${q.image}" class="battle-question-img" alt="">` : ''}
                <p class="battle-question-text">${q.question}</p>
                <div class="battle-question-points">üí∞ ${questionPoints} pontos base</div>
            </div>

            <div class="battle-options" id="options">
                ${q.options.map((opt, i) => `
                    <button class="battle-option" onclick="handleAnswer(${i})">
                        <span class="battle-option-letter">${['A', 'B', 'C', 'D'][i]}</span>
                        ${opt}
                    </button>
                `).join('')}
            </div>
        `;

        startBattleTimer();
    }

    function startBattleTimer() {
        clearInterval(battleTimer);
        battleTimer = setInterval(() => {
            timeLeft--;
            const timerEl = document.getElementById('timer');
            if (timerEl) {
                timerEl.textContent = timeLeft + 's';
                timerEl.className = 'battle-timer';
                if (timeLeft <= 10 && timeLeft > 5) timerEl.classList.add('warning');
                if (timeLeft <= 5) timerEl.classList.add('danger');
            }
            if (timeLeft <= 0) {
                clearInterval(battleTimer);
                handleAnswer(-1);
            }
        }, 1000);
    }

    function handleAnswer(idx) {
        clearInterval(battleTimer);

        const q = battle.questions[battle.currentIndex];
        const isCorrect = idx === q.correct;
        const timeTaken = (Date.now() - battle.questionStartTime) / 1000;
        const node = getNodeById(battle.nodeId);
        const multiplier = config.zoneMultipliers[node.zoneId] || 1;
        const difficulty = q.diff || battle.difficulty || 'facil';

        // === DESBLOQUEO DE PR√ÅCTICA AL RESPONDER ===
        // Se desbloquea cuando el usuario responde su primera pregunta de esa dificultad
        // (acierte o no - el punto es que haya jugado)
        if (difficulty && difficulty !== 'avancado' && !state.unlockedPractice[difficulty]) {
            state.unlockedPractice[difficulty] = true;
            saveUserState();
            
            const diffNames = { facil: 'F√°cil', media: 'M√©dia', dificil: 'Dif√≠cil' };
            unlockAchievement(`pratica_${difficulty}`);
            showToast(`üìö Pr√°tica ${diffNames[difficulty] || difficulty} desbloqueada!`);
        }

        // Visual feedback
        const btns = document.querySelectorAll('.battle-option');
        btns.forEach((btn, i) => {
            btn.disabled = true;
            if (i === q.correct) btn.classList.add('correct');
            else if (i === idx && !isCorrect) btn.classList.add('wrong');
        });

        // Calculate points using config by difficulty
        let points = 0;
        if (isCorrect) {
            battle.correct++;
            battle.streak++;
            battle.maxStreak = Math.max(battle.maxStreak, battle.streak);

            // Puntos base seg√∫n dificultad (de la config del Quiz)
            const basePoints = q.points || config.points[difficulty] || config.points.facil || 100;
            points = Math.round(basePoints * multiplier);
            
            // Bonus por racha
            points += battle.streak * config.streakBonus;
            
            // Bonus por tiempo (usando tiempo de la dificultad)
            const timeLimit = config.time[difficulty] || config.time.facil || 30;
            points += Math.round(Math.max(0, (timeLimit - timeTaken) * config.timeBonus));

            battle.score += points;
            document.getElementById('scoreValue').textContent = battle.score;
            showFloatingPoints(points, battle.streak);

            if (battle.streak === 5) unlockAchievement('streak_5');
            if (battle.streak === 10) unlockAchievement('streak_10');
            if (timeTaken < 3) unlockAchievement('resposta_rapida');
        } else {
            battle.wrong++;
            battle.streak = 0;
        }

        battle.answers.push({ correct: isCorrect, points, time: timeTaken, difficulty });
        battle.currentIndex++;

        setTimeout(() => {
            if (battle.currentIndex >= config.questionsPerBattle) {
                finishBattle();
            } else {
                showQuestion();
            }
        }, 1200);
    }

    function showFloatingPoints(points, streak) {
        const el = document.createElement('div');
        el.className = 'float-points';
        el.innerHTML = `+${points}${streak > 1 ? ` üî•√ó${streak}` : ''}`;
        el.style.cssText = 'left:50%;top:35%;transform:translateX(-50%);';
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 1300);
    }

    function finishBattle() {
        const totalTime = Math.round((Date.now() - battle.startTime) / 1000);
        const success = battle.correct >= Math.ceil(config.questionsPerBattle / 2);
        const node = getNodeById(battle.nodeId);

        let stars = 0;
        if (success) {
            stars = 1;
            if (battle.wrong === 0) {
                stars = 2;
                battle.score += config.perfectBonus;
                unlockAchievement('perfeito');
            }
            if (battle.wrong === 0 && totalTime < config.questionsPerBattle * 10) {
                stars = 3;
                unlockAchievement('velocista_campanha');
            }
        }

        if (success) {
            // Update state
            if (!state.completedNodes.includes(battle.nodeId)) {
                state.completedNodes.push(battle.nodeId);
            }
            state.nodeStars[battle.nodeId] = Math.max(state.nodeStars[battle.nodeId] || 0, stars);
            state.totalScore += battle.score;
            state.totalCorrect += battle.correct;
            state.totalWrong += battle.wrong;
            state.totalBattles++;
            state.bestStreak = Math.max(state.bestStreak, battle.maxStreak);

            // Unlock next nodes
            getAllRoutes().forEach(r => {
                if (r.from === battle.nodeId && !state.unlockedNodes.includes(r.to)) {
                    state.unlockedNodes.push(r.to);
                }
            });

            // First battle achievement
            if (state.totalBattles === 1) {
                unlockAchievement('primeiro_passo');
                unlockAchievement('iniciante');
            }

            // Zone completion check
            const zone = mapData.zones.find(z => z.nodes.some(n => n.id === battle.nodeId));
            if (zone) {
                const zoneNodes = zone.nodes.map(n => n.id);
                const allCompleted = zoneNodes.every(id => state.completedNodes.includes(id));
                if (allCompleted) {
                    unlockAchievement('conquistador');
                    // Check if all zones completed
                    const allZonesComplete = mapData.zones.every(z => 
                        z.nodes.every(n => state.completedNodes.includes(n.id))
                    );
                    if (allZonesComplete) {
                        unlockAchievement('mestre_reino');
                    }
                }
            }

            saveUserState();
            integrateWithQuizModules(battle, stars, node);

        } else {
            state.lives--;
            if (state.lives <= 0) {
                const cd = new Date();
                cd.setHours(cd.getHours() + config.cooldownHours);
                state.cooldownUntil = cd.toISOString();
                state.lives = 0;
            }
            saveUserState();
        }

        showResult(success, stars, battle.score, battle.correct, battle.maxStreak, state.lives, totalTime);
    }

    function integrateWithQuizModules(battleData, stars, node) {
        // QuizProfile
        if (typeof QuizProfile !== 'undefined' && QuizProfile.current) {
            QuizProfile.updateStats?.({
                score: battleData.score,
                correct: battleData.correct,
                wrong: battleData.wrong,
                time: Math.round((Date.now() - battleData.startTime) / 1000),
                maxStreak: battleData.maxStreak,
                difficulty: node.difficulty
            });
        }

        // QuizRanking
        if (typeof QuizRanking !== 'undefined') {
            QuizRanking.add?.({
                score: battleData.score,
                mode: 'campaign',
                nodeId: battleData.nodeId,
                stars: stars,
                nodeName: node.name,
                correct: battleData.correct,
                total: config.questionsPerBattle
            });
        }

        // QuizActivity
        if (typeof QuizActivity !== 'undefined') {
            QuizActivity.logGame?.({
                score: battleData.score,
                correct: battleData.correct,
                wrong: battleData.wrong,
                total: config.questionsPerBattle,
                mode: 'campaign',
                nodeName: node.name,
                stars: stars,
                difficulty: node.difficulty
            });
        }
    }

    function unlockAchievement(id) {
        if (typeof QuizAchievements !== 'undefined') {
            const wasNew = QuizAchievements.unlock?.(id);
            if (wasNew && !state.newAchievements.includes(id)) {
                state.newAchievements.push(id);
            }
        }
    }

    function showResult(success, stars, score, correct, maxStreak, livesLeft, time) {
        const icon = success ? (stars === 3 ? 'üèÜ' : stars === 2 ? '‚≠ê' : '‚úì') : 'üíî';
        const title = success ? (stars === 3 ? '‚ú® ELITE!' : stars === 2 ? 'ü•Ç Premium!' : '‚úàÔ∏è Aprovado!') : '‚ùå Acesso Negado';
        const subtitle = success ? '√Årea VIP desbloqueada!' : (livesLeft <= 0 ? 'Aguarde para nova tentativa...' : `${livesLeft} tentativa(s) restante(s)`);

        // Mostrar celebraci√≥n de logros SI hay logros nuevos
        if (state.newAchievements.length > 0) {
            showAchievementCelebration(state.newAchievements, () => {
                showResultScreen(icon, title, subtitle, success, stars, score, correct, maxStreak, livesLeft);
            });
        } else {
            showResultScreen(icon, title, subtitle, success, stars, score, correct, maxStreak, livesLeft);
        }
    }

    function showResultScreen(icon, title, subtitle, success, stars, score, correct, maxStreak, livesLeft) {
        document.getElementById('battleContent').innerHTML = `
            <div class="battle-result">
                <div class="battle-result-icon">${icon}</div>
                <h2 class="battle-result-title">${title}</h2>
                <p class="battle-result-subtitle">${subtitle}</p>
                ${success ? `<div class="battle-result-stars">${'‚òÖ'.repeat(stars)}${'‚òÜ'.repeat(3 - stars)}</div>` : ''}
                
                <div class="battle-result-stats">
                    <div class="battle-result-stat">
                        <div class="battle-result-stat-value" style="color:#f59e0b;">${score}</div>
                        <div class="battle-result-stat-label">Pontos</div>
                    </div>
                    <div class="battle-result-stat">
                        <div class="battle-result-stat-value" style="color:#22c55e;">${correct}/${config.questionsPerBattle}</div>
                        <div class="battle-result-stat-label">Acertos</div>
                    </div>
                    <div class="battle-result-stat">
                        <div class="battle-result-stat-value" style="color:#ef4444;">${maxStreak}</div>
                        <div class="battle-result-stat-label">Racha</div>
                    </div>
                </div>

                <button class="battle-btn" onclick="closeBattle()">
                    ${livesLeft <= 0 && !success ? 'Descansar' : 'Continuar'}
                </button>
            </div>
        `;
    }

    // ============================================
    // CELEBRACI√ìN √âPICA DE LOGROS
    // ============================================
    let currentAchievementIndex = 0;
    let achievementsToShow = [];
    let onAchievementsDone = null;

    function showAchievementCelebration(achievementIds, callback) {
        achievementsToShow = achievementIds.filter(id => {
            const ach = typeof QuizData !== 'undefined' ? QuizData.achievements?.[id] : null;
            return ach !== null;
        });
        
        if (achievementsToShow.length === 0) {
            callback();
            return;
        }

        currentAchievementIndex = 0;
        onAchievementsDone = callback;
        
        // Vibraci√≥n de celebraci√≥n
        if (navigator.vibrate) navigator.vibrate([100, 50, 100, 50, 200]);
        
        showSingleAchievement(achievementsToShow[0]);
    }

    function showSingleAchievement(achievementId) {
        const ach = QuizData.achievements?.[achievementId];
        if (!ach) {
            nextAchievement();
            return;
        }

        const rarity = ach.rarity || 'common';
        const rarityNames = {
            common: 'Comum',
            rare: 'Raro',
            epic: '√âpico',
            legendary: 'Lend√°rio'
        };

        // Crear overlay de celebraci√≥n
        const overlay = document.createElement('div');
        overlay.className = 'achievement-celebration';
        overlay.id = 'achievementOverlay';
        
        // Generar confetti
        let confettiHTML = '';
        const colors = ['#f59e0b', '#22c55e', '#3b82f6', '#a855f7', '#ef4444', '#ec4899'];
        for (let i = 0; i < 50; i++) {
            const color = colors[Math.floor(Math.random() * colors.length)];
            const left = Math.random() * 100;
            const delay = Math.random() * 0.5;
            const size = 8 + Math.random() * 8;
            const shape = Math.random() > 0.5 ? 'border-radius: 50%;' : 'transform: rotate(45deg);';
            confettiHTML += `<div class="confetti-piece" style="
                left: ${left}%; 
                background: ${color}; 
                animation-delay: ${delay}s;
                width: ${size}px;
                height: ${size}px;
                ${shape}
            "></div>`;
        }

        // Generar sparkles flotantes
        let sparklesHTML = '';
        for (let i = 0; i < 8; i++) {
            const left = 20 + Math.random() * 60;
            const top = 20 + Math.random() * 60;
            const delay = Math.random() * 2;
            sparklesHTML += `<div class="achievement-sparkle" style="
                left: ${left}%; 
                top: ${top}%; 
                animation-delay: ${delay}s;
            "></div>`;
        }

        // Dots para m√∫ltiples logros
        let dotsHTML = '';
        if (achievementsToShow.length > 1) {
            dotsHTML = '<div class="achievement-counter">';
            for (let i = 0; i < achievementsToShow.length; i++) {
                dotsHTML += `<div class="achievement-dot ${i === currentAchievementIndex ? 'active' : ''}"></div>`;
            }
            dotsHTML += '</div>';
        }

        overlay.innerHTML = `
            <div class="achievement-confetti">${confettiHTML}</div>
            ${sparklesHTML}
            
            <div class="achievement-card ${rarity}">
                <div class="achievement-rays"></div>
                <div class="achievement-new-label">‚ú® NOVO LOGRO!</div>
                
                <div class="achievement-icon">${ach.icon || 'üèÜ'}</div>
                <div class="achievement-name">${ach.name}</div>
                <div class="achievement-desc">${ach.description || 'Conquista desbloqueada!'}</div>
                <div class="achievement-rarity ${rarity}">${rarityNames[rarity]}</div>
                
                <button class="achievement-continue" onclick="nextAchievement()">
                    ${currentAchievementIndex < achievementsToShow.length - 1 ? 'Pr√≥ximo Logro ‚Üí' : 'Continuar'}
                </button>
                
                ${dotsHTML}
            </div>
        `;

        document.body.appendChild(overlay);
    }

    function nextAchievement() {
        const overlay = document.getElementById('achievementOverlay');
        if (overlay) {
            overlay.style.animation = 'achievementFadeIn 0.3s ease reverse forwards';
            setTimeout(() => overlay.remove(), 300);
        }

        currentAchievementIndex++;

        if (currentAchievementIndex < achievementsToShow.length) {
            setTimeout(() => {
                showSingleAchievement(achievementsToShow[currentAchievementIndex]);
            }, 400);
        } else {
            // Todos los logros mostrados
            setTimeout(() => {
                if (onAchievementsDone) onAchievementsDone();
            }, 400);
        }
    }

    // Hacer funci√≥n global
    window.nextAchievement = nextAchievement;

    function closeBattle() {
        document.getElementById('battleOverlay').classList.remove('active');
        battle.active = false;
        renderAll();

        if (checkCooldown()) {
            showCooldown();
        }
    }

    // ============================================
    // TOAST
    // ============================================
    function showToast(message) {
        const existing = document.querySelector('.toast');
        if (existing) existing.remove();

        const toast = document.createElement('div');
        toast.className = 'toast';
        toast.textContent = message;
        document.body.appendChild(toast);

        setTimeout(() => toast.remove(), 3000);
    }

    // ============================================
    // INITIALIZATION
    // ============================================
    document.addEventListener('DOMContentLoaded', async () => {
        console.log('üöÄ Campaign v12 initializing...');

        // Load config and map from Admin
        loadConfig();
        loadMap();

        // Initialize Quiz modules
        if (typeof QuizProfile !== 'undefined') {
            await QuizProfile.init?.();
        }
        if (typeof QuizAchievements !== 'undefined') {
            QuizAchievements.init?.();
        }
        if (typeof QuizRanking !== 'undefined') {
            QuizRanking.init?.();
        }
        if (typeof QuizActivity !== 'undefined') {
            QuizActivity.init?.();
        }

        // Load user-specific state
        loadUserState();

        // Check cooldown
        if (checkCooldown()) {
            showCooldown();
        }

        // Check for welcome cinematic
        const welcomeKey = `cartoesx_campaign_welcome_${currentUserId}`;
        if (!localStorage.getItem(welcomeKey)) {
            localStorage.setItem(welcomeKey, 'true');
            showCinematic('welcome', () => renderAll());
        } else {
            renderAll();
        }

        console.log('‚úÖ Campaign v12 ready!');
    });

    // Make functions global
    window.handleNodeClick = handleNodeClick;
    window.handleAnswer = handleAnswer;
    window.closeBattle = closeBattle;
    </script>
</body>
</html>
